using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Net.Belt.Eventing;

/// <summary>
/// Provides extension methods for working with events and property change notifications.
/// </summary>
public static class EventingExtensions
{
	/// <summary>
	/// Raises a standard <see cref="EventHandler"/> with the specified sender and event arguments.
	/// </summary>
	/// <param name="handler">The event handler to raise.</param>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">An <see cref="EventArgs"/> object that contains the event data.</param>
	public static void Raise(this EventHandler? handler, object sender, EventArgs e) => handler?.Invoke(sender, e);

	/// <summary>
	/// Raises a generic <see cref="EventHandler{TEventArgs}"/> with the specified sender and event arguments.
	/// </summary>
	/// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
	/// <param name="handler">The event handler to raise.</param>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">An object of type <typeparamref name="TEventArgs"/> that contains the event data.</param>
	public static void Raise<TEventArgs>(this EventHandler<TEventArgs>? handler,
		object sender, TEventArgs e) where TEventArgs : EventArgs =>
		handler?.Invoke(sender, e);

	/// <summary>
	/// Raises a generic <see cref="EventHandler{TEventArgs}"/> with a specific sender type and event arguments.
	/// </summary>
	/// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
	/// <typeparam name="TSender">The type of the sender.</typeparam>
	/// <param name="handler">The event handler to raise.</param>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">An object of type <typeparamref name="TEventArgs"/> that contains the event data.</param>
	public static void Raise<TEventArgs, TSender>(this EventHandler<TEventArgs>? handler,
		TSender sender, TEventArgs e) where TEventArgs : EventArgs
	{
		handler?.Invoke(sender, e);
	}

	/// <summary>
	/// Raises the <see cref="PropertyChangedEventHandler"/> for a specified property.
	/// </summary>
	/// <param name="handler">The <see cref="PropertyChangedEventHandler"/> to raise.</param>
	/// <param name="sender">The source of the event.</param>
	/// <param name="propertyName">The name of the property that changed. This is automatically populated by the compiler.</param>
	public static void Raise(this PropertyChangedEventHandler? handler, object sender,
		[CallerMemberName] string? propertyName = null) =>
		handler?.Invoke(sender, new PropertyChangedEventArgs(propertyName));

	/// <summary>
	/// Raises the <see cref="PropertyChangingEventHandler"/> for a specified property.
	/// </summary>
	/// <param name="handler">The <see cref="PropertyChangingEventHandler"/> to raise.</param>
	/// <param name="sender">The source of the event.</param>
	/// <param name="propertyName">The name of the property that is changing. This is automatically populated by the compiler.</param>
	public static void Raise(this PropertyChangingEventHandler? handler, object sender,
		[CallerMemberName] string? propertyName = null) =>
		handler?.Invoke(sender, new PropertyChangingEventArgs(propertyName));
	
	/// <summary>
	/// Notifies subscribers that a property is about to change, allowing cancellation.
	/// </summary>
	/// <typeparam name="TProp">The type of the property.</typeparam>
	/// <param name="notifier">The object raising the notification.</param>
	/// <param name="handler">The <see cref="PropertyChangingEventHandler"/> to invoke.</param>
	/// <param name="oldValue">The old value of the property.</param>
	/// <param name="newValue">The new value of the property.</param>
	/// <param name="propertyName">The name of the property that is changing. This is automatically populated by the compiler.</param>
	/// <returns><c>true</c> if the change was cancelled; otherwise, <c>false</c>.</returns>
	public static bool Notify<TProp>(this INotifyPropertyChanging notifier, PropertyChangingEventHandler? handler,
		TProp oldValue, TProp newValue,
		[CallerMemberName] string? propertyName = null)
	{
		if (handler == null) return false;
		var args = new PropertyValueChangingEventArgs<TProp>(propertyName!, oldValue, newValue);
		handler.Invoke(notifier, args);
		return args.IsCancelled;
	}

	/// <summary>
	/// Notifies subscribers that a property has changed.
	/// </summary>
	/// <typeparam name="TProp">The type of the property.</typeparam>
	/// <param name="notifier">The object raising the notification.</param>
	/// <param name="handler">The <see cref="PropertyChangedEventHandler"/> to invoke.</param>
	/// <param name="oldValue">The old value of the property.</param>
	/// <param name="newValue">The new value of the property.</param>
	/// <param name="propertyName">The name of the property that changed. This is automatically populated by the compiler.</param>
	public static void Notify<TProp>(this INotifyPropertyChanged notifier, PropertyChangedEventHandler? handler,
		TProp oldValue,
		TProp newValue, [CallerMemberName] string? propertyName = null)
	{
		handler?.Invoke(notifier, new PropertyValueChangedEventArgs<TProp>(propertyName!, oldValue, newValue));
	}

	/// <summary>
	/// Subscribes to the <see cref="INotifyPropertyChanged.PropertyChanged"/> event and returns an <see cref="IDisposable"/> that can be used to unsubscribe.
	/// </summary>
	/// <param name="notify">The object implementing <see cref="INotifyPropertyChanged"/>.</param>
	/// <param name="handler">The <see cref="PropertyChangedEventHandler"/> to subscribe.</param>
	/// <returns>An <see cref="IDisposable"/> that, when disposed, unsubscribes the handler.</returns>
	public static IDisposable Observed(this INotifyPropertyChanged notify, PropertyChangedEventHandler handler)
	{
		notify.PropertyChanged += handler;

		return new DisposableAction(() => notify.PropertyChanged -= handler);
	}

	/// <summary>
	/// Subscribes to the <see cref="INotifyPropertyChanging.PropertyChanging"/> event and returns an <see cref="IDisposable"/> that can be used to unsubscribe.
	/// </summary>
	/// <param name="notify">The object implementing <see cref="INotifyPropertyChanging"/>.</param>
	/// <param name="handler">The <see cref="PropertyChangingEventHandler"/> to subscribe.</param>
	/// <returns>An <see cref="IDisposable"/> that, when disposed, unsubscribes the handler.</returns>
	public static IDisposable Observing(this INotifyPropertyChanging notify, PropertyChangingEventHandler handler)
	{
		notify.PropertyChanging += handler;

		return new DisposableAction(() => notify.PropertyChanging -= handler);
	}
	
	/// <summary>
	/// Fires each event in the invocation list in the order in which
	/// the events were added until an event handler sets the <see cref="IChainedArgs.Handled"/>
	/// property to <c>true</c>.
	/// </summary>
	/// <remarks>Any exception that the event throws must be caught by the caller.</remarks>
	/// <param name="delegates">The multicast delegate</param>
	/// <param name="sender">The source of the event.</param>
	/// <param name="arg">An object that contains the chained event data</param>
	/// <typeparam name="T">Subtype of <see cref="ChainedArgs"/>.</typeparam>
	/// <returns><c>true</c> if an event sink handled the event, <c>false</c> otherwise.</returns>
	public static bool Raise<T>(this ChainedEventHandler<T>? delegates, object sender, T arg) where T : ChainedArgs
	{
		bool handled = false;
		// Assuming the multicast delegate is not null...
		if (delegates != null)
		{
			// Call the methods until one of them handles the event
			// or all the methods in the delegate list are processed.
			Delegate[] invocationList = delegates.GetInvocationList();

			for (int i = 0; i < invocationList.Length && !handled; i++)
			{
				((ChainedEventHandler<T>)invocationList[i])(sender, arg);
				handled = arg.Handled;
			}
		}
		// Return a flag indicating whether an event sink handled
		// the event.
		return handled;
	}
	
	/// <summary>
	/// Fires each event in the invocation list in the order in which
	/// the events were added until an event handler's return value satisfies the provided <paramref name="predicate"/>.
	/// </summary>
	/// <remarks>Any exception that an event handler throws must be caught by the caller.</remarks>
	/// <param name="delegates">The multicast delegate.</param>
	/// <param name="sender">The source of the event.</param>
	/// <param name="args">An object that contains the event data.</param>
	/// <param name="predicate">A function that determines if the event has been handled based on the return value of an event handler.</param>
	/// <typeparam name="T">The type of the event arguments, which must implement <see cref="IMutableArgs{TResult}"/>.</typeparam>
	/// <typeparam name="K">The type of the result returned by the event handlers.</typeparam>
	/// <returns><c>true</c> if an event sink handled the event (i.e., the predicate returned <c>true</c>), <c>false</c> otherwise.</returns>
	public static bool RaiseUntil<T, K>(this ChainedEventHandler<T, K>? delegates, object sender, T args, Func<K, bool> predicate) where T : IMutableArgs<K>
	{
		bool handled = false;

		if (delegates != null)
		{
			Delegate[] invocationList = delegates.GetInvocationList();
			for (int i = 0; i < invocationList.Length && !handled; i++)
			{
				K result = ((ChainedEventHandler<T, K>)invocationList[i])(sender, args);
				handled = predicate(result);
			}
		}
		return handled;
	}
}